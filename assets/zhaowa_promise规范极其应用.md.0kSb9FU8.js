import{_ as s,o as a,c as n,R as l}from"./chunks/framework.LBXiIpgL.js";const o="/assets/跨标签页面通信.jyMlTTaS.png",p="/assets/浏览器原理.9ENuCpPi.png",e="/assets/任务队列.kenbcdAk.png",t="/assets/事件循环.5QL2U9Q9.png",q=JSON.parse('{"title":"promise 和浏览器原理","description":"","frontmatter":{},"headers":[],"relativePath":"zhaowa/promise规范极其应用.md","filePath":"zhaowa/promise规范极其应用.md"}'),c={name:"zhaowa/promise规范极其应用.md"},r=l(`<h1 id="promise-和浏览器原理" tabindex="-1">promise 和浏览器原理 <a class="header-anchor" href="#promise-和浏览器原理" aria-label="Permalink to &quot;promise 和浏览器原理&quot;">​</a></h1><h3 id="什么叫异步" tabindex="-1">什么叫异步 <a class="header-anchor" href="#什么叫异步" aria-label="Permalink to &quot;什么叫异步&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 异步执行</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> count </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> timer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> () {</span></span>
<span class="line"><span style="color:#E1E4E8;">  count</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;in&quot;</span><span style="color:#E1E4E8;">, count);</span></span>
<span class="line"><span style="color:#E1E4E8;">}, </span><span style="color:#79B8FF;">1000</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;out&quot;</span><span style="color:#E1E4E8;">, count);</span></span>
<span class="line"><span style="color:#6A737D;">// out 1 =&gt; in 2</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 为什么？</span></span>
<span class="line"><span style="color:#6A737D;">// 循环执行 + 终止</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> count </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> timer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setInterval</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> () {</span></span>
<span class="line"><span style="color:#E1E4E8;">  count</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;in&quot;</span><span style="color:#E1E4E8;">, count);</span></span>
<span class="line"><span style="color:#E1E4E8;">}, </span><span style="color:#79B8FF;">1000</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;out&quot;</span><span style="color:#E1E4E8;">, count);</span></span>
<span class="line"><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> () {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">clearInterval</span><span style="color:#E1E4E8;">(timer);</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;clear&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}, </span><span style="color:#79B8FF;">3000</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">// out 1 =&gt; in 2 =&gt; in 3 =&gt; in 3 =&gt; in 4 =&gt; clear</span></span>
<span class="line"><span style="color:#6A737D;">// 解释一下：在第五秒的时候队列中有setInterval，也有setTimeout，然后按照顺序先后执行，所以还会出现一个4才会被清除掉</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 存在看不见的队列，存在需要执行的指令 放在回调函数中</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 异步执行</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> count </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> timer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> () {</span></span>
<span class="line"><span style="color:#24292E;">  count</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;in&quot;</span><span style="color:#24292E;">, count);</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">1000</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;out&quot;</span><span style="color:#24292E;">, count);</span></span>
<span class="line"><span style="color:#6A737D;">// out 1 =&gt; in 2</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 为什么？</span></span>
<span class="line"><span style="color:#6A737D;">// 循环执行 + 终止</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> count </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> timer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setInterval</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> () {</span></span>
<span class="line"><span style="color:#24292E;">  count</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;in&quot;</span><span style="color:#24292E;">, count);</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">1000</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;out&quot;</span><span style="color:#24292E;">, count);</span></span>
<span class="line"><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> () {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">clearInterval</span><span style="color:#24292E;">(timer);</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;clear&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">3000</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6A737D;">// out 1 =&gt; in 2 =&gt; in 3 =&gt; in 3 =&gt; in 4 =&gt; clear</span></span>
<span class="line"><span style="color:#6A737D;">// 解释一下：在第五秒的时候队列中有setInterval，也有setTimeout，然后按照顺序先后执行，所以还会出现一个4才会被清除掉</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 存在看不见的队列，存在需要执行的指令 放在回调函数中</span></span></code></pre></div><h3 id="进程-线程-协程" tabindex="-1">进程 &amp;&amp; 线程 &amp;&amp; 协程 <a class="header-anchor" href="#进程-线程-协程" aria-label="Permalink to &quot;进程 &amp;&amp; 线程 &amp;&amp; 协程&quot;">​</a></h3><blockquote><p>js 是单线程的语言，为什么？设计之初就是这样设计的，就是为简单交互准备的,没有想到后续会有这么庞大的使用</p></blockquote><h4 id="a-概念和区别" tabindex="-1">a. 概念和区别 <a class="header-anchor" href="#a-概念和区别" aria-label="Permalink to &quot;a. 概念和区别&quot;">​</a></h4><ul><li>进程：进程是 CPU <strong>资源分配</strong>的最小单位，（资源分配）不同进程之间资源不共享</li><li>线程：线程是 CPU <strong>调度</strong>的最小单位（执行任务）</li></ul><h4 id="面试题-一个浏览器的-tab-页面是一个单独的线程还是进程或者说浏览器新开一个窗口" tabindex="-1">面试题： 一个浏览器的 tab 页面是一个单独的线程还是进程或者说浏览器新开一个窗口？ <a class="header-anchor" href="#面试题-一个浏览器的-tab-页面是一个单独的线程还是进程或者说浏览器新开一个窗口" aria-label="Permalink to &quot;面试题： 一个浏览器的 tab 页面是一个单独的线程还是进程或者说浏览器新开一个窗口？&quot;">​</a></h4><ul><li>从资源的角度来看：不同的 tab 页面的资源是独立的，隔离的，不共享的，所以是单独的进程</li></ul><h4 id="追问-窗口-tab-页面-进程之间通信-跨标签页通信" tabindex="-1">追问：窗口/tab 页面/ 进程之间通信 /跨标签页通信 <a class="header-anchor" href="#追问-窗口-tab-页面-进程之间通信-跨标签页通信" aria-label="Permalink to &quot;追问：窗口/tab 页面/ 进程之间通信 /跨标签页通信&quot;">​</a></h4><ul><li>storage、cookie 等 <img src="`+o+'" alt="Alt text"></li></ul><h4 id="追问-多种存储的区别" tabindex="-1">追问：多种存储的区别 <a class="header-anchor" href="#追问-多种存储的区别" aria-label="Permalink to &quot;追问：多种存储的区别&quot;">​</a></h4><h4 id="追问-安全性、应用场景" tabindex="-1">追问：安全性、应用场景 <a class="header-anchor" href="#追问-安全性、应用场景" aria-label="Permalink to &quot;追问：安全性、应用场景&quot;">​</a></h4><h4 id="追问-在你的项目中是如何做的-如何体现的-如页面中的实时同步-如两个表单关闭其中一个-另一个的回显" tabindex="-1">追问：在你的项目中是如何做的，如何体现的（如页面中的实时同步，如两个表单关闭其中一个，另一个的回显，） <a class="header-anchor" href="#追问-在你的项目中是如何做的-如何体现的-如页面中的实时同步-如两个表单关闭其中一个-另一个的回显" aria-label="Permalink to &quot;追问：在你的项目中是如何做的，如何体现的（如页面中的实时同步，如两个表单关闭其中一个，另一个的回显，）&quot;">​</a></h4><p>混合前端中多个 webview 是进程还是线程？ - 可以自己分析一下，视情况而定</p><h4 id="方向二-浏览器的原理" tabindex="-1">方向二： 浏览器的原理 <a class="header-anchor" href="#方向二-浏览器的原理" aria-label="Permalink to &quot;方向二： 浏览器的原理&quot;">​</a></h4><h4 id="面试题-桌面级别的应用中两个独立的页面时独立的线程还是进程" tabindex="-1">面试题： 桌面级别的应用中两个独立的页面时独立的线程还是进程 <a class="header-anchor" href="#面试题-桌面级别的应用中两个独立的页面时独立的线程还是进程" aria-label="Permalink to &quot;面试题： 桌面级别的应用中两个独立的页面时独立的线程还是进程&quot;">​</a></h4><ul><li>不太确定二者是否资源是独立的。但是二者执行的任务是不相同的，两个页面获得的内存分配是一样的，</li></ul><blockquote><p>区分：定位上看：资源共享上：从目的上看：是否执行相同的任务 协程： 两个独立之间的共享的一些东西或者辅助的一些东西，这些实际上是将各个独立的资源进行统一的分配共享</p></blockquote><h3 id="浏览器的原理" tabindex="-1">浏览器的原理 <a class="header-anchor" href="#浏览器的原理" aria-label="Permalink to &quot;浏览器的原理&quot;">​</a></h3><p>进程之间端口号不同，方便进行外部通信 webRTC GUI 渲染和 JS 线程是有顺序的，html 的位置和 script 的位置，按照顺序执行 <img src="'+p+'" alt="Alt text"></p><h4 id="执行栈-js-单线程" tabindex="-1">执行栈 - js 单线程 <a class="header-anchor" href="#执行栈-js-单线程" aria-label="Permalink to &quot;执行栈 - js 单线程&quot;">​</a></h4><p><img src="'+e+'" alt="Alt text"></p><h4 id="备注-js-堆栈执行顺序和退栈溢出-白屏" tabindex="-1">备注：JS 堆栈执行顺序和退栈溢出 =&gt; 白屏 <a class="header-anchor" href="#备注-js-堆栈执行顺序和退栈溢出-白屏" aria-label="Permalink to &quot;备注：JS 堆栈执行顺序和退栈溢出 =&gt; 白屏&quot;">​</a></h4><h3 id="_2-event-loop-事件循环机制" tabindex="-1">2. event-loop 事件循环机制： <a class="header-anchor" href="#_2-event-loop-事件循环机制" aria-label="Permalink to &quot;2. event-loop 事件循环机制：&quot;">​</a></h3><p><img src="'+t+`" alt="Alt text"></p><ul><li>执行顺序题</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;out&quot;</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 宏任务2</span></span>
<span class="line"><span style="color:#E1E4E8;">}, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">// 整体形成属于宏任务1</span></span>
<span class="line"><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Promise</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">resolve</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;new promise&quot;</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 1、跟随同步逻辑进入主线程 ，promise的主结构是同步的 回调才会进入队列</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">resolve</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"><span style="color:#E1E4E8;">  .</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;promise then&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  })</span></span>
<span class="line"><span style="color:#E1E4E8;">  .</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;promise then then&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  });</span></span>
<span class="line"><span style="color:#6A737D;">//  new promise</span></span>
<span class="line"><span style="color:#6A737D;">// promise then</span></span>
<span class="line"><span style="color:#6A737D;">// promise then then</span></span>
<span class="line"><span style="color:#6A737D;">// out</span></span>
<span class="line"><span style="color:#6A737D;">// promise中注册和执行是两码事 注册是同步的，执行是异步的</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;out&quot;</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 宏任务2</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6A737D;">// 整体形成属于宏任务1</span></span>
<span class="line"><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">Promise</span><span style="color:#24292E;">((</span><span style="color:#E36209;">resolve</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;new promise&quot;</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 1、跟随同步逻辑进入主线程 ，promise的主结构是同步的 回调才会进入队列</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">})</span></span>
<span class="line"><span style="color:#24292E;">  .</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;promise then&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  })</span></span>
<span class="line"><span style="color:#24292E;">  .</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;promise then then&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  });</span></span>
<span class="line"><span style="color:#6A737D;">//  new promise</span></span>
<span class="line"><span style="color:#6A737D;">// promise then</span></span>
<span class="line"><span style="color:#6A737D;">// promise then then</span></span>
<span class="line"><span style="color:#6A737D;">// out</span></span>
<span class="line"><span style="color:#6A737D;">// promise中注册和执行是两码事 注册是同步的，执行是异步的</span></span></code></pre></div><h2 id="promise" tabindex="-1">promise <a class="header-anchor" href="#promise" aria-label="Permalink to &quot;promise&quot;">​</a></h2><h3 id="回调地狱" tabindex="-1">回调地狱 <a class="header-anchor" href="#回调地狱" aria-label="Permalink to &quot;回调地狱&quot;">​</a></h3><p><a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint" target="_blank" rel="noreferrer">https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint</a></p>`,31),E=[r];function i(y,u,h,m,F,d){return a(),n("div",null,E)}const b=s(c,[["render",i]]);export{q as __pageData,b as default};
