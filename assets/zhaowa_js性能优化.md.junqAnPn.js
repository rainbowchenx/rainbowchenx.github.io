import{_ as a,o as l,c as i,R as e}from"./chunks/framework.LBXiIpgL.js";const t="/assets/浏览器加载钩子.F3kA0Dq9.svg",n="/assets/CDN.e2YKI43H.png",b=JSON.parse('{"title":"js 性能优化","description":"","frontmatter":{},"headers":[],"relativePath":"zhaowa/js性能优化.md","filePath":"zhaowa/js性能优化.md"}'),o={name:"zhaowa/js性能优化.md"},s=e('<h1 id="js-性能优化" tabindex="-1">js 性能优化 <a class="header-anchor" href="#js-性能优化" aria-label="Permalink to &quot;js 性能优化&quot;">​</a></h1><h2 id="性能指标计算" tabindex="-1">性能指标计算 <a class="header-anchor" href="#性能指标计算" aria-label="Permalink to &quot;性能指标计算&quot;">​</a></h2><h3 id="navigation-timing-api" tabindex="-1">navigation timing api <a class="header-anchor" href="#navigation-timing-api" aria-label="Permalink to &quot;navigation timing api&quot;">​</a></h3><h3 id="performancenavigationtiming" tabindex="-1">PerformanceNavigationTiming <a class="header-anchor" href="#performancenavigationtiming" aria-label="Permalink to &quot;PerformanceNavigationTiming&quot;">​</a></h3><blockquote><p>提供了用于存储和检索有关浏览器文档事件的指标的方法和属性。例如，此接口可用于确定加载或卸载文档需要多少时间 单页面不存在这个问题，因为从头到尾只维护一个实例，不存在跳转等问题<br> 通过<code>window.performance.getEntries()[0] === PerformanceNavigationTiming</code>获取</p></blockquote><img src="'+t+`" data-fancybox="gallery" style="background-color:#fff;"><ol><li><p>navigationStart - 表示从上一个页面开始要进行跳转的最初钩子</p></li><li><p><code>unloadEventStart / End</code> - 表示前一个页面 unload 事件处理程序开始/结束的时间点</p></li><li><p><code>redirectStart / End</code> - 发生重定向的事件开始和结束的时间(首次进入没有重定向的值)</p></li><li><p><code>fetchStart</code> - 浏览器<strong>准备</strong>好使用 http 请求抓取文档的时间</p></li><li><p><code>domainLookupStart / End</code> - http 开始/重新建立连接的时间 - 衡量域名解析时间长短的指标 长短连接之间的区别，不同版本 http 的对于 tcp 的实现方式</p></li><li><p><code>connectStart / End</code> - 浏览器尝试建立连接到服务器的时间点和成功建立连接的时间点 =&gt; 只包含前后端相关，纯数据连接的时间</p></li><li><p><code>secureConnectionStart / End</code> - ssl 层加密连接 https 开始和结束的时间</p></li><li><p><code>requestStart</code> - 浏览器开始发起网络请求的时间点</p></li><li><p><code>responseEnd</code> - 浏览器接收到资源的时间点</p></li><li><p><code>domLoading</code> - 开始解析并构建 dom 树的时间 <code>domInteractive</code> - 完成 dom 解析的时间 <code>domContentLoadedEventStart / End</code> ：网页内部资源内容加载的时间(已经下载完成待加载)；这个指标表示触发文档的 DOMContentLoaded 事件的时间点 <code>domComplete</code> - dom 渲染基本完成的时间</p></li><li><p><code>loadEventStart / End</code> - load 事件回调函数开始执行 / 执行完毕的点</p></li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// index.html</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    javascript:(()=&gt;{</span></span>
<span class="line"><span style="color:#E1E4E8;">        var perData </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> window.performance.timing</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    })()</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// index.html</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    javascript:(()=&gt;{</span></span>
<span class="line"><span style="color:#24292E;">        var perData </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> window.performance.timing</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    })()</span></span>
<span class="line"><span style="color:#24292E;">    &lt;/</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><h2 id="core-web-vitals-网页性能的核心指标" tabindex="-1">Core Web Vitals - 网页性能的核心指标 <a class="header-anchor" href="#core-web-vitals-网页性能的核心指标" aria-label="Permalink to &quot;Core Web Vitals - 网页性能的核心指标&quot;">​</a></h2><h3 id="补充-first-contentful-paint-fcp" tabindex="-1">补充：First Contentful Paint (FCP) <a class="header-anchor" href="#补充-first-contentful-paint-fcp" aria-label="Permalink to &quot;补充：First Contentful Paint (FCP)&quot;">​</a></h3><p>从网页开始加载到网页任何部分呈现在屏幕上所用的时间</p><ol><li>减少阻塞渲染资源的加载</li><li>去除未使用的 css JavaScript 代码</li><li>避免网页的多次重定向</li><li>缩短服务器响应时间（TTFB）</li><li>减少请求的数量和传输大小</li><li>高效的缓存信息</li></ol><h3 id="largest-contentful-paint-lcp" tabindex="-1">Largest Contentful Paint(<a href="https://web.dev/articles/lcp?hl=zh-cn" target="_blank" rel="noreferrer">LCP</a>)： <a class="header-anchor" href="#largest-contentful-paint-lcp" aria-label="Permalink to &quot;Largest Contentful Paint([LCP](https://web.dev/articles/lcp?hl=zh-cn))：&quot;">​</a></h3><p>视口内可见的最大图片或者文本块的呈现时间 - 衡量页面的装载性能</p><ul><li>前 2.5s 内进行最大内容的渲染（公司以 1200ms 作为优秀基准）</li></ul><ol><li><p>最大内容包含了哪些？</p><ul><li><code>&lt;img&gt;</code> 元素</li><li><code>&lt;svg&gt;</code> 元素</li><li><code>&lt;video&gt;</code> 元素</li><li>通过 <code>url()</code>函数加载的背景图片</li><li>块级元素, 包含了文本节点或者其他内联文本元素子集的</li></ul></li><li><p>LCP 值低下的原因</p><ul><li>服务响应慢</li><li>阻断渲染的 js 和 css</li><li>资源的加载</li><li>项目的渲染</li></ul></li><li><p>针对性改造</p><ul><li><strong>使用缓存</strong> 离线页面/资源缓存/请求内容的缓存 =&gt; 减少浏览器对于服务的请求 | 减少服务的查询<br> =&gt; 强缓存和协商缓存 | 缓存机制</li><li><strong>针对阻断渲染</strong>：css 和 js 进行压缩 | 合并 | 级联 | 内联； 后置 JS 逻辑</li><li>对于文件的优化 =&gt; 对于格式的优化 转化图片的格式为 WEBP 或者 JPG =&gt; 图片的格式 =&gt; 加载和显示<br> =&gt; 云资源管理加速资源加载</li><li><strong>工程化</strong>：<br> =&gt; 打包优化 - gzip 压缩 分片 异步 懒加载<br> =&gt; 框架层面 - 拆分异步模块、统一封装<br> =&gt; 写法： 合并网络请求、及时清理垃圾,释放内存<br> =&gt; 同构： 结合客户端渲染与服务端渲染</li></ul></li></ol><h3 id="first-input-delay-fid" tabindex="-1">first input delay - FID <a class="header-anchor" href="#first-input-delay-fid" aria-label="Permalink to &quot;first input delay - FID&quot;">​</a></h3><p>页面首次输入延迟应该小于 100ms</p><ol><li>js 的执行时间过长 <ul><li>缩小/压缩 js 文件</li><li>延迟加载不需要的 js 逻辑(defer async 或者配置动态加载)</li><li>尽量减少未使用的 polyfill(垫片)</li></ul></li><li>分解耗时任务 <ul><li>时间超过 50ms 的可以说是长任务</li><li>长任务拆分为前置或者后置或者多个短任务</li></ul></li><li>workers <ul><li>通过 worker 提高执行效率，并且实现实时同步</li></ul></li></ol><h3 id="cumulative-layout-shift-cls" tabindex="-1">cumulative layout shift - CLS <a class="header-anchor" href="#cumulative-layout-shift-cls" aria-label="Permalink to &quot;cumulative layout shift - CLS&quot;">​</a></h3><p>衡量视觉稳定性 页面抖动评分,或者说布局偏移</p><ul><li>元素布局移动可能发生的位置偏移量</li></ul><ol><li>不使用无尺寸元素（图片，广告， 嵌入内容 iframe 等）</li><li>减少内部内容的插入，即动态插入的内容</li><li>字体的控制: 默认字体为先 =&gt; 本地替换字体 =&gt; 加载字体</li></ol><h4 id="cwv-core-web-vitals-annotations-最好的当然还是-performance" tabindex="-1">CWV core web vitals annotations - 最好的当然还是 performance <a class="header-anchor" href="#cwv-core-web-vitals-annotations-最好的当然还是-performance" aria-label="Permalink to &quot;CWV core web vitals annotations - 最好的当然还是 performance&quot;">​</a></h4><h3 id="大厂的前端监控体系" tabindex="-1">大厂的前端监控体系 <a class="header-anchor" href="#大厂的前端监控体系" aria-label="Permalink to &quot;大厂的前端监控体系&quot;">​</a></h3><ol><li>埋点上报 =&gt; 点到点的上报 + 信息采集汇总</li><li>数据处理 =&gt; 阈值设置 / 数据分类（来源） / 数据重组（）</li><li>可视化展现 =&gt; grafana / 自研报表</li><li>告警处理 =&gt; 告警触发 / 触发分派 =&gt; 钉钉等</li></ol><h3 id="未来可能-bigpipe-页面分解为若干个-pagelet" tabindex="-1">未来可能 - bigpipe - 页面分解为若干个 pagelet <a class="header-anchor" href="#未来可能-bigpipe-页面分解为若干个-pagelet" aria-label="Permalink to &quot;未来可能 - bigpipe - 页面分解为若干个 pagelet&quot;">​</a></h3><ol><li>服务前端接收来自客户端的 https 请求与</li><li>从存储层获取数据</li><li>生成 html，作为部分模板的基础</li><li>浏览器去生成解析内容， 遗留区域作为展示面板在客户端进行渲染</li><li>加载渲染生成</li></ol><h3 id="性能优化通用方向和手段" tabindex="-1">性能优化通用方向和手段： <a class="header-anchor" href="#性能优化通用方向和手段" aria-label="Permalink to &quot;性能优化通用方向和手段：&quot;">​</a></h3><ol><li>尽量减少重定向 ： 301 - 永久重定向 302 - 临时重定向 <ul><li>重定向需要浏览器在新位置发出额外的 http 请求，所以会有额外耗时</li><li>减少重定向的方式包括减少同源重定向 - 比如将用户从 example.com/page/ 重定向到 example.com/page。在网页之间创建内部链接时，您应避免链接到通过重定向进行响应的网页，而是直接链接到正确的位置。和减少跨源重定向</li></ul></li><li>缓存 HTML 响应：即使用强缓存或者协商缓存，</li><li>衡量服务器响应时间 - 使用 Server-Timing 响应标头公开在服务器上停留的时间，其中包含对用户身份验证的时间和数据库访问的时间</li><li>各种压缩手段 - 使用 Brotil 压缩手段或者 gzip 设置 content-encoding 为 br；后者的压缩能力更强 动态压缩和静态压缩</li><li>内容分发网络（CDN）：</li></ol><h2 id="content-delivery-networks-cdn" tabindex="-1">Content delivery networks（CDN） <a class="header-anchor" href="#content-delivery-networks-cdn" aria-label="Permalink to &quot;Content delivery networks（CDN）&quot;">​</a></h2><p>组成：由经过优化、可快速向用户分发内容的服务器网络组成 优势：</p><ul><li>CDN 服务器比源服务器更靠近用户，因此 RTT 延迟短，且 CDN 无需将请求传递到源服务器</li><li>流程： 客户端和附近的 CDN 建立新连接，然后进行数据传输，CDN 和源服务器之间保持持久连接，这样可以消除不必要的连接成本 <img src="`+n+'" alt="CDN" data-fancybox="gallery"></li><li>CDN 缓存：CDN 从源站请求资源并缓存响应</li></ul>',33),r=[s];function c(p,d,h,g,u,m){return l(),i("div",null,r)}const v=a(o,[["render",c]]);export{b as __pageData,v as default};
